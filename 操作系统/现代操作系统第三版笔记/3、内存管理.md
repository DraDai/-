# 3、内存管理

### 1.1、内存的原理

#### 1.1.1、==内存的基础知识==

-  **什么是内存？有何作用**

  > **内存**（Random Access Memory, RAM）是计算机系统中存储临时数据和程序指令的硬件。它是与CPU直接通信的存储器，用于存储在当前运行程序时需要的数据和指令。
  >
  > 内存的作用：
  >
  > 1. **程序执行的临时存储**：内存用于存储正在运行的程序和它们的相关数据。
  > 2. **数据交换的快速缓冲区**：内存中的数据可以被高速读写，是CPU与硬盘之间的缓冲区。

  - **存储单元、内存地址的概念和联系**
    - **存储单元：**内存是由大量存储单元组成的，每个存储单元可以存储一个数据单元（通常是1个字节）。这些单元是连续排列的。
    - **内存地址**：每个存储单元都有唯一的编号，这个编号就是内存地址，用于标识和访问内存中的特定单元。CPU通过地址来读取和写入数据。
  - **按字节编址VS按字编址**
    - **按字节编址**：内存的每一个字节都有一个唯一的地址，字节是内存中最小的可寻址单元。
    - **按字编址**：有些计算机按“字”来编址，“字”可以是2字节、4字节或8字节，每个字对应一个地址。
    - **区别**：按字节编址意味着可以访问任意一个字节的内存，而按字编址时，每次读取的最小单位是一个字。

- **进程运行的基本原理**

  - **指令的工作原理**

    > **指令执行过程**：每条指令由CPU按照取指（Fetch）、译码（Decode）和执行（Execute）三个步骤完成。指令由操作码和操作数构成，操作码决定要执行的操作，而操作数是操作的对象。

  - **逻辑地址VS物理地址**

    - **逻辑地址**：程序员在程序中使用的地址，是进程运行时生成的相对地址。
    - **物理地址**：内存中的**实际地址**。CPU通过内存管理单元（MMU）将逻辑地址转换为物理地址。

  - **从写程序到程序运行的过程**

    - **编辑源代码文件：**程序员使用编程语言编写源代码，并保存为文本文件（如`.c`、`.java`）
    - **编译**：编译器将源代码转换为机器码（目标文件），该机器码是CPU能够理解的二进制指令。
    - **链接**：链接器将多个目标文件以及库文件合并为一个可执行文件，解决符号引用的依赖。
    - **装入**：操作系统将可执行文件加载到内存中，并为其分配内存资源，进而开始执行程序。

  - **三种链接方式**

    - **静态链接**：

      > **定义**：在编译时，所有所需的库函数和模块都会直接嵌入到最终的可执行文件中，生成的可执行文件是自包含的，不需要外部库。
      >
      > **优点**：无需外部依赖，执行时更快。
      >
      > **缺点**：生成的可执行文件较大，更新库时需要重新编译。

    - **装入时动态链接**：

      > **定义**：程序在装入内存时，所需的动态库（如`.dll`或`.so`文件）被装入程序的内存空间，执行时动态调用这些库。
      >
      > **优点**：可执行文件较小，库更新后不需要重新编译程序。
      >
      > **缺点**：程序运行时需要依赖这些外部库，装入时可能会有性能开销。

    - **运行时动态链接**：

      > **定义**：程序在运行时才加载和链接所需的模块，而不是在装入时完成。这种链接允许程序在运行时选择所需的模块。
      >
      > **优点**：更加灵活，可以动态加载和卸载库。
      >
      > **缺点**：运行时开销较大，且需要处理库的动态加载问题。

  - **三种装入方式**

    - **绝对装入**：

      > **定义**：可执行文件生成时，编译器为所有指令和数据指定绝对的物理内存地址，装入时直接按照这些地址进行装入。
      >
      > **优点**：无需额外的地址转换，直接运行。
      >
      > **缺点**：缺乏灵活性，程序必须装入指定的地址，无法在不同内存位置运行。

    - **可重定位装入**：

      > **定义**：编译器生成相对地址，操作系统在装入时对地址进行**重定位**，将逻辑地址变换为物理地址。
      >
      > **特点**：在一个作业装入内存时**必须分配其要求全部内存地址空间**，如果没有足够的内存，就不能装入该作业。作业一旦进入内存后，**在运行期间就不能移动**。
      >
      > **优点**：程序可以装入不同的内存位置，更加灵活。
      >
      > **缺点**：装入时需要进行地址转换，增加了复杂度。

    - **动态运行时装入**：

      > **定义**：装入程序把装入模块装入内存后，不会立即把逻辑地址转化为物理地址，而是把**地址转换推迟到程序真正要运行的时候才进行**。因此装入内存后所有的地址依然是逻辑地址。
      >
      > **优点：**允许程序在内存中发生移动。 



#### 1.1.2、==内存管理的概念==

- **内存空间的分配与回收**

  > 内存管理是操作系统中非常重要的一个部分，它负责给进程分配内存空间，以及在进程终止或不再需要使用时回收内存。

- **内存空间的扩充（实现虚拟性）**

  > 虚拟内存的引入是为了提供更大的内存空间以及更高效的内存管理。虚拟内存的核心思想是将程序所需的内存地址空间与物理内存解耦，使得程序看起来可以使用比实际物理内存更多的内存。

- **地址转换**

  > 地址转换是将程序中的逻辑地址（虚拟地址）转换为物理内存中的实际地址的过程。操作系统通过地址转换机制（由硬件支持的MMU）实现这一过程。

- **存储保护**
  内存保护是指防止进程非法访问它不应当访问的内存区域，确保系统稳定性和数据安全性。操作系统和硬件共同实现内存保护机制。

  

#### 1.1.3、==覆盖与交换==

- **覆盖技术**

  > **覆盖技术**是一种早期用于内存管理的技术，主要在内存容量有限时使用。它的基本思想是将一个程序分成若干模块，在不同的时间段加载到同一块内存区域，从而通过“覆盖”的方式解决内存不足的问题。

  - **一个固定区**：
    - 存放最活跃的程序段
    - **固定区中的程序段在运行的过程中不会被调入调出**（比如main函数）
  - **若干覆盖区**
    - 互斥运行的程序段可共享一个覆盖区。
    - **覆盖区的程序段在运行过程中会根据需要调入调出**
  - **缺点：**
    - **程序复杂度高**：程序员需要手动管理模块的加载和覆盖，增加了开发的复杂性。
    - **效率低**：频繁的内存覆盖导致程序执行效率下降。
    - **动态性不足**：覆盖技术的内存管理较为静态，不适合现代操作系统的动态内存需求。

- **交换技术**

  > **交换技术**是一种内存扩展机制，当系统内存不足时，操作系统可以将暂时不需要的进程或数据从内存移到外存中的**交换区**，以腾出空间给其他进程使用。当被交换的进程需要再次执行时，再将其从外存调回内存。

  - **进程切换：**当内存不足时，整个进程或部分内存空间的数据被临时交换到磁盘交换区，释放出内存。
  - **优点**：
    - **内存利用率高**：通过交换技术，可以动态地扩展内存的可用性，使系统在物理内存不足的情况下仍能处理更多的进程。
    - **自动化管理**：操作系统自动进行内存交换，程序员无需手动管理内存。

- **覆盖与交换的区别**

  | **覆盖技术**                                 | **交换技术**                             |
  | :------------------------------------------- | :--------------------------------------- |
  | 静态管理，程序员手动划分模块并管理内存覆盖。 | 动态管理，由操作系统自动调度内存的使用。 |
  | 适用于早期内存小的环境。                     | 适用于现代操作系统的内存管理。           |
  | 覆盖只发生在内存内部，不涉及外存。           | 涉及内存与外存之间的数据交换。           |
  | 程序运行时只能使用有限的固定内存区域。       | 通过交换，可以有效地扩展内存空间。       |
  | 程序复杂度高，需要手动设计和实现。           | 自动进行，降低了程序的复杂性。           |



#### 1.1.4、==连续分配管理==

> 连续分配管理是内存管理的一种方式，它**将主存空间划分为若干连续的分区，每个分区都能够分配给不同的进程或程序使用。**该方法中的内存分配是基于连续地址空间的，不允许进程占用的内存区域出现不连续的情况。连续分配管理方式可以进一步分为三种类型：单一连续分配、固定分区分配和动态分区分配。

- **单一连续分配**

  > 单一连续分配是最简单的一种内存管理方式，它的主要特点是将整个内存划分为两部分：一部分用于操作系统，另一部分用于单一的用户程序。

  - **特点：**只支持弹道程序，每次仅允许一个程序在内存中运行，实现简单，无需复杂的内存管理算法。
  - 缺点：内存利用率低，很容易出现**内部碎片**（分配给进程的中的没有用上的内存区域）

- **固定分区分配**

  > 固定分区分配是将内存划分为若干个固定大小的分区，每个分区可以分配给不同的进程使用。分区的数量和大小在系统初始化时已经确定。

  - **特点：**支持多道程序，内存用户空间分为若干个固定大小的分区，每个分区只能装一道作业。
  - 缺点：容易产生**内部碎片**，不适用于大规模、多进程的现代系统。

- **动态分区分配**

  > 动态分区分配又称为可变分区分配，这种分配方式**不会预先划分内存分区**，而是在进程装入内存的时候**根据进程的大小动态地建立分区**，使分区的大小正好适合进程的需要。

  - **记录内存使用情况的两种数据结构**
    - **空闲分区表**：**空闲分区表**是一种通过表格来记录系统中所有空闲内存分区的方式，每一行表示一个空闲的内存块，包括它的起始地址和大小等信息。
    - **空闲分区链表**：**空闲分区链表**是另一种记录空闲内存的方法，使用链表的结构来跟踪空闲内存块，每个空闲内存块作为链表中的一个节点。

  - 按照**动态分区分配算法**从空闲分区分配给该作业。

  - **四种情况回收空闲分区**

    - **前后分区均不空闲**（不合并）
      - **描述**：待回收的分区前后均为已使用的分区，没有相邻的空闲分区。
      - **操作**：只需要将当前的待回收分区标记为空闲，并插入到空闲分区表或链表中。
      - **结果**：待回收的分区作为一个独立的空闲块存在，不进行合并。

    - **前分区空闲，后分区不空闲**（与前分区合并）

      - **描述**：待回收分区前面是一个空闲分区，后面是已使用的分区。

      - **操作**：将待回收分区与前面的空闲分区合并，形成一个更大的空闲块。

      - **结果**：新的空闲分区起始地址是前一个空闲块的地址，大小是两块的和。

    - **前分区不空闲，后分区空闲**（与后分区合并）

      - **描述**：待回收分区前面是已使用的分区，后面是一个空闲分区。

      - **操作**：将待回收分区与后面的空闲分区合并，形成一个更大的空闲块。

      - **结果**：新的空闲分区起始地址为待回收分区的地址，大小是两块的和。

    - **前后分区均空闲**（与前后分区同时合并）

      - **描述**：待回收分区的前后都是空闲分区。

      - **操作**：将待回收分区与前后的两个空闲分区同时合并，形成一个更大的空闲块。

      - **结果**：新的空闲分区起始地址为前面空闲分区的地址，大小为三块分区的总和。

  - **缺点**：虽然动态分配减少了内部碎片问题，但是会产生**外部碎片**（即随着内存的分配和回收，空闲内存被分割成许多不连续的小块，可能导致无法为大进程分配足够的连续空间。）



#### 1.1.5、==动态分区分配算法==

- **首次适应算法**
  - **算法思想**：每次都从低地址开始查找，找到第一个能满足大小的空闲分区。
  - **实现**：**空闲分区以地址递增的次序排列**，每次分配内存时顺序查找**空闲分区链（表）**，找到大小能满足要求的第一个空闲分区。
- **最佳适应算法**
  - **算法思想**：由于动态分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域。为保证大进程到来时有连续的大片空间，**可以尽可能地留下大片的空闲区，即优先使用更小地空闲区**。
  - **实现**：空闲分区**按容量递增次序链接**，每次分配内存时按顺序查找**空闲分区链（表）**，找到大小能满足的第一个空闲分区。
  - **缺点**：容易产出很多外部碎片
- **最坏适应算法**
  - **算法思想**：为了解决最佳适应算法的问题，可以在每次分配时优先使用最大的连续空闲区，这样分配后的空闲区就不会太小，更方便使用。
  - **实现**：空闲分区按**容量递减次序链接**，每次分配内存时顺序查找空闲分区链（表），找到大小能满足的第一个空闲分区。
  - **缺点**：缺少大空闲分区
- **邻近适应算法**
  - **算法思想**：首次适应算法每次都从链头开始查找会导致低地址部分出现很多小的空闲分区，而每次分配查找时都要经过这些分区，因此也增加了查找的开销。如果每次都从上次查找结束的位置开始检索，就能解决上述问题。
  - **实现**：空闲分区以地址递增的顺序排列（可排成一个循环链表）。**每次分配内存时从上次查找结束的位置开始查找空闲分区链（表）**，找到大小能满足要求的第一个空闲分区。



#### 1.1.6、==分页存储管理==

