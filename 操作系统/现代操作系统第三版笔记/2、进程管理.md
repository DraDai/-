# 2、处理机管理

### 2.1、进程管理

#### 2.1.1、==进程的概念、组成、特征==

- **进程的概念：**

  > 程序：是**静态**的，就是一个存放在磁盘里的可执行文件，他是一系列的指令集合。
  >
  > 进程（Process）：是**动态的**，是程序的一次执行过程。即便是同一个程序多次进行，对应的也是多个不同的进程。

- **进程实体的组成**：

  > 进程实体是进程执行过程中某一刻的状态，它是由PCB、程序段和数据段组成。

  - **PCB（Process Control Block）进程控制块：**一个数据结构，主要记录对进程进行管理工作的各种信息，**是进程存在的唯一标志**。
    - **进程描述信息**
      - 进程标识符PID：每个PID都是唯一的。
      - 用户标识符UID：使用进程的用户ID
    - **进程控制和管理信息**
      - CPU、磁盘、网络流量使用情况统计……
      - 进程当前状态：就绪态/阻塞态/运行态……
    - **资源分配清单**
      - 正在使用哪些文件
      - 正在使用哪些内存区域
      - 正在使用哪些I/O设备
    - **处理机相关信息**：如PSW、PC等各种寄存器的值（用于实现进程切换）
  - **程序段**：包含程序指令的序列。
  - **数据段：**运行过程中产生的各种数据。

- **进程的特征：**

  - **动态性（进程最基本的特征）**：进程是程序的一次执行过程，是动态地产生、变化和消亡地
  - **并发性**：内存中有多个进程实体，各进程可并发执行。
  - **独立性：**进程是能独立运行、独立获得资源、独立接受调度地基本单位。
  - **异步性：**各进程按照各自独立、不可预知地速度向前推进。
  - **结构性**。

#### 2.1.2、==进程的状态与转换==

- **进程的状态：**

  - **创建态**：进程正在被创建，在这个阶段操作系统会为进程分配资源、初始化PCB。
  - **就绪态**：当进程创建完成后，便进入**就绪态**，处于就绪态的进程已经具备运行条件，但由于没有空闲CPU，就暂时不能运行。
  - **运行态：**当CPU空闲时，操作系统就会选择一个就绪进程，让他在处理机上运行。此时运行在CPU上的进程就叫做**运行态**。CPU会执行进程对应的程序。
  - **阻塞态**：在进程运行的过程，可能会请求等待某个事件的发生，此时进程无法继续往下执行，那么操作系统会让这个进程进入**阻塞态**。
  - **终止态：**进程运行结束或者出现错误，操作系统会使进程进入**终止态**，使该进程下CPU，并回收内存空间等资源，最后回收该进程的PCB。

- **进程状态的转换**

  ![image-20240912180252513](C:\Users\di\Desktop\新建文件夹\image-20240912180252513.png)

- **进程的组织方式**

  - **链接方式**

    <img src="C:\Users\di\Desktop\新建文件夹\image-20240912180411329.png" alt="image-20240912180411329" style="zoom: 25%;" />

  - **索引方式**
    <img src="C:\Users\di\Desktop\新建文件夹\image-20240912180507297.png" alt="image-20240912180507297" style="zoom:25%;" />

#### 2.1.3、==进程控制==

> 进程控制的主要功能是**对系统中的所有进程实施有效的管理**，它具有创建新进程、撤销已有进程、实现进程转换等功能。
>
> 而要实现进程控制，就必须要用**原语**来实现。

- **原语的实现**
  - 原语的执行具有**原子性**，期间不允许中断，可以用**开中断指令**和**关中断指令**这两个**特权指令**来实现原子性。
  - 当一段内核程序使用了关中断指令后，CPU就不再例行检查中断信号，直到执行了开中断指令之后才会恢复检查。
  - 在关中断、开中断之间的指令序列是不可被中断的，这个指令序列就是原语。
- **进程的创建**
  - **创建原语**：操作系统创建一个进程时使用的原语
    - 申请空白PCB
    - 为新进程分配所需资源
    - 初始化PCB
    - 将PCB插入就绪队列，使进程从创建态转变为就绪态
  - **引起进程创建的事件：**
    - 用户登录：分时系统中，用户登录成功，系统会为其建立一个新的进程。
    - 作业调度：多道批处理系统中，有新的作业被放入内存时，会为其建立一个新的进程。
    - 提供服务：用户向系统提出某些请求时，会新建一个进程处理该请求。
    - 应用请求：由用户进程主动创建一个子进程。
- **进程的终止**
  - **撤消原语**
    - 从PCB集合中找到终止进程的PCB。
    - 若进程正在运行，立即剥夺CPU，将CPU分配给其他进程。
    - 终止其所有子进程。
    - 将该进程拥有的所有资源归还给父进程或者操作系统。
    - 删除PCB。
  - 引起进程终止的事件
    - 正常结束：进程自己请求终止。
    - 异常结束：由于进程的异常行为被系统强行终止。
    - 外界干预：用户手动终止进程。
- **进程的阻塞和唤醒**
  - **进程的阻塞：**
    - **阻塞原语**
      - 找到要阻塞的进程对应的PCB
      - 将进程运行环境保存进PCB，将PCB状态信息设置为阻塞态，暂时停止进程运行。
      - 将PCB插入相应事件的等待序列。
    - 引起进程阻塞的事件
      - 需要等待系统分配某种资源。
      - 需要等待互相合作的其他进程完成工作。
  - **进程的唤醒：**
    - **唤醒原语**
      - 在事件等待序列中找到PCB
      - 将PCB从等待序列中移出，设置进程为就绪态。
      - 将PCB插入就绪队列，等待被调度。
    - 引起进程唤醒的事件：等待的事件发生。
- **进程的切换**
  - **切换原语：**就绪态切换为运行态
    - 将进程运行环境信息存入PCB。
    - PCB移入相应的队列
    - 选择另一个进程执行，并更新PCB
    - 根据PCB恢复新进程所需的运行环境。
  - 引起进程切换的事件
    - 当前进程时间片到
    - 有更高级的进程到达。
    - 当前进程主动阻塞。
    - 当前进程终止。



#### 2.1.4、==进程通信==

> **进程间通信（IPC）**是指两个进程之间产生数据交互。进程是分配系统资源的单位，各进程拥有的内存地址空间相互独立。
>
> 为了保证安全，**一个进程不能直接访问另一个进程的地址空间**，所以进程间通信需要操作系统支持。
>
> 进程通信主要有三种方式，分别是**共享存储、消息传递、管道通信**。

- **共享存储**

  > 操作系统会开辟一个共享存储区，两个要通信的进程可以在共享存储区进行访问。为避免出错，各个进程对共享空间的访问应该是互斥的。

  - **基于存储区的共享**

    > 这种模式中，共享存储区内数据的形式、存放位置**都由通信进程控制**，而不是操作系统。
    >
    > 这种共享速度很快，是一种高级通信方式。

  - **基于数据结构的共享**

    > 共享空间内只能存放长度固定的数据结构，这种共享速度慢，限制多，是一种低级通信方式。

- **消息传递**

  > 进程间的数据以**格式化的信息（Message）**为单位。进程通过操作系统提供的“发送信息/接受信息”两个原语进行数据交换。![image-20241004100037127](C:\Users\di\Desktop\新建文件夹\image-20241004100037127.png)

  - **直接通信方式**		

    - 进程P要给进程Q发送消息，首先进程p会在自己的地址空间初始化消息msg。

    - 然后进程P使用**发送原语send(Q, msg)**，指明接收方的进程ID，将消息发送到进程Q的PCB中的**消息队列**。 

    - 最后进程Q使用**接收原语receive(P,&msg)**，指明发送方的进程ID，在自己的消息队列中找到进程P发送过来的消息。

  - **间接通信方式**
    - 操作系统在内核地址空间创建有几个信箱（中间实体），发送进程可以使用发送原语指明信箱ID，将消息发送到信箱内，接收进程可以使用接收原语指明信箱ID，从信箱中找到适合自己的消息。
    - 多个发送进程可以向同一个信箱发送消息，多个接收进程也可以从同一个信箱接收消息。

- **管道通信**

  - ![image-20241004103815351](C:\Users\di\Desktop\新建文件夹\image-20241004103815351.png)



### 2.2、线程

#### 2.2.1、==线程的概念==

 ![image-20241004112034911](C:\Users\di\Desktop\新建文件夹\image-20241004112034911.png)

- **引入线程带来的变化**
  - 在传统进程机制中，进程是资源分配、调度的基本单位。引入线程后，进程是资源分配的基本单位，线程是调度的基本单位。
  - 引入线程后，个线程间也能并发，提高了并发度。
  - 传统的进程间并发，需要切换进程的运行环境，系统的开销很大。引入线程后，如果是同一进程中的线程切换，就不用切换进程环境，系统开销变小。
- **线程的属性**
  - ![image-20241004112526425](C:\Users\di\Desktop\新建文件夹\image-20241004112526425.png)



#### 2.2.2、==线程的实现方式和多线程模型==

- **线程的实现方式**

  - **用户级线程**
    - 用户级线程由应用程序通过线程库实现，所有的**线程管理工作**都由**应用程序负责**（包括线程切换）。
    - 用户级线程中，线程切换可以在**用户态下即可完成**，无需操作系统干预。
    - **优点：**用户级线程的切换不需要切换到核心态，线程管理的系统开销小，效率高。
    - **缺点**：当一个用户级线程被阻塞后，整个进程会被阻塞，并发度不高。**多个线程不能在多核处理机上并行运行**。
    - ![image-20241005103533220](C:\Users\di\Desktop\新建文件夹\image-20241005103533220.png)

  - **内核级线程**
    - 内核级线程的管理工作由**操作系统内核**完成。
    - 线程调度、切换等工作都由内核负责，因此**内核级线程的切换**必须要在**核心态**下才能完成。
    - 操作系统会为每个内核级线程建立相应的线程控制块（TCB），通过TCB对线程进行管理。
    - **优点**：并发性强，多线程可以在多核处理机上并行运行。
    - **缺点**：管理成本高、开销大。

- **多线程模型**

  - **一对一模型**
    - 一个用户级线程映射到一个内核级线程。每个用户进程有与用户级线程相同数量的内核级线程，
    - **优点**：当一个线程被阻塞后，别的线程可以继续执行，并发能力强。多线程可在多核处理机上并行执行。
    - **缺点**：管理成本高，开销大。
    - ![image-20241005104356800](C:\Users\di\Desktop\新建文件夹\image-20241005104356800.png)

  - **多对一模型**
    - 一个进程只被分配一个内核级线程，多个用户级线程映射到一个内核级线程。
    - 用户级线程的切换在用户空间即可完成，无需切换到核心态，系统开销小、效率高。
    - 当一个用户级线程被阻塞时，整个进程就会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行。
    - ![image-20241005104937018](C:\Users\di\Desktop\新建文件夹\image-20241005104937018.png)

  - **多对多模型**

    - n个用户线程映射到m个内核级线程(n>m)，每个用户进程对应m个内核级线程。

    - 克服了多对一模型并发度不高的缺点，克服了一对一模型中一个用户进程开销太大的缺点。

      <img src="C:\Users\di\Desktop\新建文件夹\image-20241005105257867.png" alt="image-20241005105257867" style="zoom:33%;" />



#### 2.2.3、==线程的状态与转换==

> 线程的状态与转换与进程的状态与转换几乎相同。
>
> ![image-20241005105619315](C:\Users\di\Desktop\新建文件夹\image-20241005105619315.png)

> 线程的组织与控制也与进程的组织与控制几乎相同
>
> ![image-20241005105912696](C:\Users\di\Desktop\新建文件夹\image-20241005105912696.png)



### 2.3、处理机调度

#### 2.3.1、==调度的概念、层次==

> 当有一堆任务要处理，但由于资源有限，有些事情没法同时处理。这就需要某种规则来决定处理这些任务地**顺序**，这就是**调度**研究的问题。

- **调度的三个层次**

  - **高级调度**（作业调度）

    - 按一定的原则从外存的作业后备队列中挑选一个作业调入内存，并创建进程。
    - **每个作业只调入一次、调出一次**，作业调入时建立PCB，调出时撤销PCB。

  - **中级调度**（内存调度）

    > 内存不足时，可将某些进程的**数据**调出外存。等内存空闲或者进程需要运行时再重新调入内存。
    >
    > 暂时调到外存等待的进程状态为**挂起状态**，被挂起的进程PCB会被组织成**挂起队列**。

    - 中级调度会按照某种策略决定将哪个处于挂起状态的进程重新调入内存。	

  - **低级调度**（进程调度/处理机调度）

    - 按照某种策略从就绪队列中选取一个进程，将处理机分配给它。
    - 进程调度是操作系统**最基本的一种调度**，在一般的操作系统中都必须配置进程调度。

- **进程的挂起态与七状态模型**
  ![image-20241006093343132](C:\Users\di\Desktop\新建文件夹\image-20241006093343132.png)

- **三层调度的联系、对比**
  ![image-20241006093555205](C:\Users\di\Desktop\新建文件夹\image-20241006093555205.png)



#### 2.3.2、==进程调度==

- **进程调度的时机**

  - **需要进行进程调度与切换的情况**

    - 当前运行的进程**主动放弃处理机**：
      - 进程正常终止。
      - 进程运行过程中发生异常而终止。
      - 进程主动要求阻塞。
    - 当前运行的进程**被动放弃处理机**
      - 分给进程的时间片用完
      - 有更紧急的事需要处理
      - 有更高优先级的进程进入就绪队列。

  - **不能进行进程调度与切换的情况**

    - 在**处理中断的过程中。**中断处理过程复杂，与硬件密切相关，很难做到在中断处理过程中进行进程切换。

    - 进程在**操作系统内核程序临界区中**，注意：进程在普通临界区中可以被进程调度。

      > 临界资源：一个时间段只允许一个进程使用的资源。各进程只能互斥地访问临界资源。
      >
      > 临界区：访问临界资源地那段代码

    - 在原子操作过程中。

- **进程调度的方式**

  > 不同的操作系统对进程调度的方式不同，分为**非剥夺调度方式**和**剥夺调度方式**

  - **非剥夺调度方式（非抢占方式）**
    - 只允许进程主动放弃处理机，在运行过程中即便有更紧急的任务到达，当前进程依然会继续使用处理机。
    - 实现简单，系统开销小，但无法及时处理紧急任务，适合早期的批处理系统。
  - **剥夺调度方式（抢占方式）**
    - 如果有更紧急的进程需要使用处理机，当前执行的进程会被立即停止。
    - 可以优先处理更紧急的进程，也可以实现让各进程按时间片轮流执行的功能。适用于分时操作系统、实时操作系统。

- **进程调度的切换与过程**

  > 狭义的进程调度只表示从就绪队列中选出一个要运行的进程。
  >
  > 而广义的进程调度包括选择进程和进程切换两个步骤。

  - 进程切换过程
    - 对原来运行进程各种数据的保存。
    - 对新的进程各种数据的恢复。
  - 进程调度、切换是有代价的，切换的越快，处理进程代码的时间就越少。

- **闲逛进程**

  - 当没有其他就绪进程时，会运行**闲逛进程**.
  - 闲逛进程的特性：
    - 优先级最低
    - 可能是0地址指令，占一个完整的指令周期。
    - 能耗低。



#### 2.3.3、==调度算法的评价指标==

- **CPU利用率**（指CPU忙碌的时间占总时间的比例）
  - 利用率 = $\frac{忙碌的时间}{总时间}$

- **系统吞吐量**

  > 对系统来说，希望用尽可能少的时间处理完尽可能多的作业

  - 系统吞吐量指的是单位时间内完成作业的数量
  - $系统吞吐量 = \frac{总共完成了多少道作业}{总共花了多少时间}$

- **周转时间**

  > 对计算机用户来说，他很关心自己的作业从提交到完成花了多少时间
  >
  > **周转时间**是指**作业从提交給系统开始，到完成作业为止**的这段时间间隔。

  - $周转时间 = 作业完成时间-作业提交时间$
  - **平均周转时间** = $\frac{各作业周转时间之和}{作业数}$
  - **带权周转时间**（实际上是无效时间率）= $\frac{周转时间}{作业实际运行的时间}$
    - 带权周转时间必然>1, **带权周转时间和周转时间都是越小越好**
  - **平均带权周转时间** = $\frac{各作业带权周转时间之和}{作业数}$

- **等待时间**

  > 等待时间指的是进程或作业处于**等待处理机状态时间之和**，等待时间越长，用户满意度越低。

  - 对于**进程**来说，等待时间就是指进程建立后**等待被服务的时间之和**，在等待I/O完成的期间其实进程也是在被服务的，所以不计入等待时间。
  - 对于**作业**来说，不仅要考虑**建立进程后的等待时间，还要加上作业在外存后备队列中等待的时间**。

- **响应时间**
  - 从用户提交请求到首次产生响应所用的时间。



#### 2.3.4、==调度算法==

- **先来先服务（first come first server)FCFS**

  -  **算法思想：**主要从公平的角度考虑（类似于排队买东西）
  - **算法规则**：按照作业/进程**到达的先后顺序**进行服务。
  - **用于作业/进程调度：**用于作业调度时，考虑的是哪个作业先到达后备队列；用于进程调度时，考虑的是哪个进程先到达就绪队列。
  - 属于非抢占式算法。
  - **优缺点：**
    - **优点：**公平、算法实现简单
    - **缺点**排在长作业（进程）后面的短作业（进程）需要等待很长时间，带权周转时间很大，对短作业来说用户体验不好，即FCFS算法对**长作业有利，对短作业不利**。
  - 不会导致饥饿。

- **短作业优先（SJF, Shortest Job First），短进程优先（SPF, Shortest Process First）**

  - **算法思想**：追求最少的平均等待时间，最少的平均周转时间、最少的平均带权周转时间。

  - **算法规则**：最短的作业/进程得到服务（所谓最短，指的是要求服务时间最短）

    > SJF和SPF属于非抢占式算法，在每次调度时选择**当前已到达且运行时间最短**的作业/进程。
    >
    > 抢占式的短作业优先算法叫做**最短剩余时间优先算法（SRTN）**：
    >
    > ​	每当有新进程加入就绪队列时就需要调度，如果新到达的进程剩余时间比当前运行的进程剩余时间更短，则由新进程**抢占处理机**，当前运行进程回到就绪队列。另外，当另一个进程完成时也需要调度。

  - **优缺点：**
    - 优点：非抢占式中最短的平均等待时间、平均周转时间。
    - 缺点：对短作业有利，对长作业不利，可能产生饥饿现象。另外，作业/进程的运行时间是由用户提供的，并不一定真实，不一定做到真正的短作业优先。

- **高响应比优先（HRRN, Highest Response Ratio Next）**

  - **算法思想：**综合考虑作业/进程的等待时间和要求服务的时间。

  - **算法规则：**在每次调度时计算各个作业/进程的**响应比**，选择响应度最高的作业/进程为其服务。

    > **响应比**=$\frac{等待时间+要求服务时间}{要求服务时间}$
    >
    > HRRN是非抢占式算法，只有当前运行的进程**主动放弃CPU**时，才需要进行调度。

    - **优缺点：**
      - **优点**：综合考虑了等待时间和运行时间。等待时间相同时，要求服务时间短的进程优先；要求服务时间相同时，等待时间长的进程优先。对于长作业来说，随着等待时间越来越久，其响应比也会越来越大，从而避免了**长作业饥饿的问题**

- **时间片轮转（RR, Round-Robin)**

  - **算法思想**：公平的轮流的为各个进程服务，让每个进程在一定时间间隔内都可以得到响应。

  - **算法规则：**按照各个进程到达的顺序，轮流让各个进程执行一个时间片，若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放入**就绪队列队尾重新排序**

    > 如果时间片太大，使每个进程都可以在一个时间片内就完成，则时间片轮转算法退化为FCFS，并且会增大进程响应时间，因此**时间片不能太大**。
    >
    > 如果时间片太小，会导致**进程切换过去频繁**，系统会花大量时间来处理切换，从而导致进程执行的时间比例减少。可见**时间片也不能太小**。
    >
    > 一般来说，设计时间片时要让切换进程的开销占比不超过1%。

  - **只用于进程调度**：只有作业放入内存建立了相应的进程后，才能被分配处理机时间片。
  - 属于抢占式算法，由时钟装置发出**时钟中断**来通知CPU时间片已到。
  - **优缺点**：
    - **优点**：公平，响应快，适用于分时操作系统，不会导致饥饿。
    - **缺点**：由于高频率的进程切换，因此有一定的开销，不区分任务的紧急程度。

- **优先级调度算法**

  - **算法思想**：随着计算机的发展，特别是实时操作系统的出现，越来越多的应用场景需要根据任务的紧急程度来决定处理顺序。

  - **算法规则**：每个作业/进程都有各自的优先级，调度时选择优先级最高的作业/进程。**优先数越大，优先级越高**。

    > **非抢占式的优先级调度算法：**每次调度时选择当前已到达且优先级最高的进程。当前进程主动放弃处理机时发生调度。
    >
    > **抢占式的优先级调度算法**：与非抢占式不太的是，抢占式在**就绪队列发生改变时会检查是否有比当前运行进程优先级更高的进程出现**，如果出现就替换。

    - 优先级分为两种：
      - **静态优先级**：创建进程时确定，之后不会改变。
      - **动态优先级：**创建进程时有一个初始值，之后会根据情况动态地调整优先级，如果某进程在就绪队列中等待了很长时间，则可以适当提升其优先级，如果某进程占用处理机运行了很长时间，则可以适当降低其优先级
    - 通常情况下，系统进程优先级高于用户进程，前台进程优先级高于后台进程，并且操作系统更偏向于I/O型进程。

  - **优缺点：**

    - **优点：**用优先级区分紧急程度、重要程度，适用于实时操作系统。可灵活的调整对各个作业/进程的偏好程度。
    - **缺点：**若源源不断有高优先级的进程到来，则可能会导致饥饿。

- **多级反馈队列调度算法**

  - **算法思想：**对其他调度算法的折中权衡。

  - **算法规则：**

    - 设置多级就绪队列，各优先级从高到低，时间片从小到大分配。

    - 新进程到达时先进入第一级队列，按FCFS原则排队等待被分配时间片。若完成时间片进程还未结束，则进程进入下一级队列队尾。如果此时已经是最底层队列时，则重新放入该队列队尾。

    - 只有第k级队列为空时，才会为k+1级队头的进程分配时间片。

      ![image-20241008121842424](C:\Users\di\Desktop\新建文件夹\image-20241008121842424.png)

  - 只用于进程调度。
  - 属于抢占式算法，当k级队列的进程正在运行，如果更上层的队列进入了一个新进程，那么就会被抢占。
  - **优缺点**：
    - 优点：对各类型进程相对公平，每个新到达的进程都能够很快响应，短进程较少时间即可完成，不必实现估计进程运行时间，可灵活调整对各类进程的偏好程度。
    - **缺点**：可能会导致饥饿

- **多级队列调度算法**

  - ![image-20241009090124332](C:\Users\di\Desktop\新建文件夹\image-20241009090124332.png)



### 2.4、进程同步

#### 2.4.1、==进程同步与进程互斥的概念==

- **进程同步**
  - **同步**亦称**直接制约方式**，他是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上**协调**他们的**工作次序**而产生的制约关系。进程间的直接制约关系就是来源于他们之间的相互合作。
- **进程互斥**
  - **概念**：对临界资源的访问，需要互斥的进行。即同一时间段内只允许一个进程访问该资源。
  - **进程互斥可分为四个部分**
    - **进入区：**检查是否可以进入临界区，若可进入，需要上锁。
    - **临界区：**访问临界资源的那部分代码。
    - **退出区：**负责解锁。
    - **剩余区：**其余部分代码。
  - **需要遵循的原则：**
    - **空闲让进：**临界区空闲时，应运行一个进程访问。
    - **忙则等待：**临界资源正在被访问时，其他试图访问的进程需要等待。
    - **有限等待：**要在有限的时间内进入临界区，保证不会饥饿。
    - **让权等待：**进不了临界区的进程，要释放处理机，防止忙等。



#### 2.4.2、==进程互斥的软件实现方法==

- **单标志法**

  - **算法思想**：一个进程在**访问完临界区**后会把使用临界区的权限交给另一个进程。也就是说**每个进入临界区的权限只能被另一个进程赋予**。

  - ```c
    int turn = 0;	//turn表示当前允许进入临界区的进程号
    
    //P0进程：
    while(turn != 0);	//进入区
    critical section;	//临界区
    turn = 1;			//退出区
    remainder section;	//剩余区
    
    //P1进程
    while(turn != 1);	//当turn不等于1时，P1进程会一直检查进程号是否等于1，直到时间片结束
    critical section;
    turn = 0;
    remainder section;
    ```

  - 该算法可以实现**同一时刻最多只允许一个进程访问临界区**。

  - 该算法的缺点是，如果进程P0将临界区让给P1，但P1没有使用临界区，那么P0就无法再次使用临界区，因为P1没有让权。这违反了**空闲让进**原则。

- **双标志先检查法**

  - **算法思想**：设置一个布尔型数组flag[]，数组各个元素来**标记各个进程想进入临界区的意愿**，比如flag[0] = true意味着0号进程P0现在想要进入临界区。每个进程在进入临界区之前先检查当前有没有别的进程想进入临界区，如果没有就把自身对应的表示flag[i]设为true，之后开始访问临界区。

  - ```c
    bool flag[2];	//表示进入临界区意愿的数组
    flag[0] = false;
    flag[1] = false;	//刚开始设置为两个进程都不想进入临界区
    
    //P0进程
    while(flag[1]);
    flag[0] = true;
    critical section;
    flag[0] = false;
    remainder section;
    
    //p1进程
    while(flag[0]);		//进入区：如果此时P0想进入临界区，P1就一直循环等待
    flag[1] = true;		//标记为p1程序想要进入临界区
    critical section;	//访问临界区
    flag[1] = false;	//访问完临界区，修改标记为p1不想使用临界区
    remainder section;
    ```

  - 如果在一个进程”检查“后，”上锁“发生了进程切换，可能会导致两个进程同时访问临界区，这违反了**忙则等待**原则。

- **双标志后检查法**

  - **算法思想**：由于双标志先检查法的先检查后上锁机制会导致两个进程同时进入临界区的问题，所以人们又想到**先上锁后检查**的方法来避免上述问题

  - ```c
    bool flag[2];	//标识进入临界区意愿的数组
    flag[0] = false;
    flag[1] = false;
    
    //P0进程
    flag[0] = true;
    while(flag[1]);
    critical section;
    flag[0] = false;
    remainder section;
    
    //P1进程
    flag[1] = true;		//进入区，上锁标记P1进程想进入临界区
    while(flag[0]);		//判断P0进程是否有进入临界区的意愿，有则等待
    critical section;	//访问临界区
    flag[1] = false;	//访问完临界区，修改标记为P1不想使用临界区
    remainder section;
    ```

  - 如果两个进程同时对一个临界区上锁，会导致它们都卡在死循环中无法推进，造成**饥饿现象**，这违背了**空闲让进和有限等待**原则。

- **Peterson算法**

  - **算法思想**：结合双标志法、单标志法的思想。如果双方都争着想进入临界区，那可以让进程尝试谦让。

  - ```c
    bool flag[2];	//表示有进入临界区意愿的两个数组，初始值都是false
    int turn = 0;	//turn 表示优先让哪个进程进入临界区
    
    //p0进程
    flag[0] = true;	//表示P0进程想访问临界区
    ture = 1;		//表示将访问权谦让给P1进程
    while(flag[1] && true == 1);	//当P1进程有意愿访问临界区，并且没有将访问权谦让给自己，就会等待资源
    critical section;
    flag[0] = false;	//表示P0进程已经不想访问临界区了
    remainder section;
    
    //P2进程
    flag[1] = true;	//表示P1进程想访问临界区
    ture = 0;		//表示将访问权谦让给P0进程
    while(flag[0] && true == 0);	//当P0进程有意愿访问临界区，并且没有将访问权谦让给自己，就会等待资源
    critical section;
    flag[0] = false;	//表示P1进程已经不想访问临界区了
    remainder section;
    ```

  - Peterson算法解决了进程互斥问题，**遵循了空闲让进、忙则等待，有限等待**三个原则，但是并未遵循让权等待的原则。



#### 2.4.3、==进程互斥的硬件实现方法==

- **中断屏蔽方法**

  > 利用“开/关中断指令”实现 ，即在某进程开始访问临界区到结束访问为止都不被允许中断，也就不能发生进程切换，因此也不可能发生两个进程同时访问临界区的情况

  - 优点：简单高效
  - 缺点：不适应于多处理机，因为这种方式无法控制其他处理机的执行；不适用于用户进程，太过危险，只允许运行在内核态。

- **TestAndSet指令**

  - 简称**TS**指令，也有地方称为**TestAndSetLock**指令，或**TSL**指令。

  - TSL指令由硬件实现，执行过程不允许被中断。

  - ```c
    //C语言模拟TestAndSet指令，实际上TS指令是由硬件实现的
    
    //布尔型公共变量 lock 表示当前临界区是否被加锁
    bool TestAndSet(bool *lock){
        boo old = *lock;	//old变量来存放lock指向地址里的bool值
        lock = true;	//不管lock是否被加锁，自己在lock上加锁
        return old;		//返回lock的原来值
    }
    
    //使用TL指令实现进程互斥的算法逻辑
    while(TestAndSet(&lock));	//检查加上锁，检查到在上锁之前lock已经被上锁，等待
    critical section;	//访问临界区
    *lock = false;	//解锁
    remainder section;
    ```

  - 该指令实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；适用于多处理机环境

  - 缺点：不满足**让权等待**，暂时无法进入临界区的进程会占用CPU一直循环TSL指令直到时间片结束，这导致了忙等。

- **Swap指令**

  - 也叫**Exchange指令**，或简称**XCHG**指令。

  - **Swap指令**是由硬件实现的，执行的过程中不被中断。

  - ```c
    //C语言模拟逻辑
    
    //Swap指令的作用是交换两个变量的值
    void Swap(bool *a, bool *b){
        bool temp;
        temp = *a;
        *a = *b;
        *b = temp;
    }
    
    //使用Swap指令实现互斥的算法逻辑
    //lock表示临界区是否被加锁
    bool old = true;
    while(old == true){//这段循环也是检查加上锁，一气呵成	
        Swap(&old, &lock);	
    }
    critical section;	//访问临界区
    *lock = false;	//解锁
    remainder section;
    ```

  - 由于逻辑和TSL指令一样，所以优缺点都一样。



#### 2.4.4、==互斥锁==

![image-20241010110808086](C:\Users\di\Desktop\新建文件夹\image-20241010110808086.png)

![image-20241010110832130](C:\Users\di\Desktop\新建文件夹\image-20241010110832130.png)

#### 2.4.5、==信号量机制== 

![image-20241011102354216](C:\Users\di\Desktop\新建文件夹\image-20241011102354216.png)

- **整型信号量**

  - 用一个**整数型的变量**作为信号量，用来**表示系统中某种资源的数量**。

  - ```c
    int S = 1;	//初始化整型信号量s，表示当前系统中可用的打印机资源数
    
    void wait(int S){	//wait原语相当于进入区
        while(S <= 0);	//如果资源数不够，就一直循环等待
        S=S-1;	//如果资源数够，则占用一个资源
    }
    
    void signal(int S){	//signal 原语，相当于退出区
        S = S + 1;	//使用完成，在退出区释放资源
    }
    
    //进程P0;
    ...
    wait(S);	//进入区，申请资源
    critical section;	//临界区，访问资源
    signal(S);	//退出区，释放资源；
    ...
    ```

  - 缺点：会导致忙等，不满足让权等待。

- **记录型信号量  **

  - 记录型信号量：即用记录型数据结构表示的信号量

  - ```c
    //记录型信号量的定义
    typedef struct{
        int value;	//剩余资源数
        struct proecss *L;	//等待队列（阻塞队列）
    }semaphore;
    
    //某进程需要使用资源时，通过wait原语申请
    void wait(semaphore S){
        S.value--;
        if(S.value < 0){	//如果资源数不够，使用block原语使进程从运行态进入到阻塞态，并把进程挂到信号量S的等待队列中
            block(S.L);
        }
    }
    
    //进程使用完资源后，通过signal原语释放
    void signal(semaphore S){
        s.value++;
        if(S.value <= 0){	//若释放资源后还有别的进程等待资源，则使用wakeuo原语唤醒等待队列中的一个进程，该进程从阻塞态变为就绪态
            wakeup(S.L);
        }
    }
    
    //进程P0;
    ...
    wait(S);	//进入区，申请资源
    critical section;	//临界区，访问资源
    signal(S);	//退出区，释放资源；
    ...
    ```

  - 对信号量的一次P操作意味着**请求一个单位的该类资源**，如果没有资源可用，则会自动的进入阻塞态。遵循了**让权等待**原则。

  - 对信号量的一次V操作意味着**释放一个单位的该类资源**，如果还有其他进程等待资源，会自动唤醒一个阻塞态进程。



#### 2.4.6、==信号量机制实现进程互斥、进程同步、进程前驱关系==

- **信号量机制实现进程互斥**

  - 分析并发进程的关键活动，划定临界区。

  - 设置**互斥信号量mutex**，初值为1。

  - 在进入区P（mutex）-- 申请资源

  - 在退出区V(mutex) -- 释放资源

    > 对**不同临界资源**需要**设置不同的互斥信号量**。
    >
    > PV操作必须成对出现。

- **信号量机制实现进程同步**

![image-20241011121000863](C:\Users\di\Desktop\新建文件夹\image-20241011121000863.png)

- **信号量机制实现前驱关系**

  ![image-20241011121545983](C:\Users\di\Desktop\新建文件夹\image-20241011121545983.png)

#### 2.4.7、==生产者、消费者问题== 

- **问题描述**
  ![image-20241012121235402](C:\Users\di\Desktop\新建文件夹\image-20241012121235402.png)

- **问题分析**

  ![image-20241012121426122](C:\Users\di\Desktop\新建文件夹\image-20241012121426122.png)

- **功能实现**

  - ```c
    semaphore mutex = 1;	//互斥访问信号量，实现对缓冲区的互斥访问
    semaphore empty = n;	//同步信号量，表示空闲缓冲区的数量
    semaphore full = 0;		//同步信号量，表示产品的数量，也就是非空缓冲区的数量
    
    //生产者
    producer(){
        while(1){
            生产一个产品;
            P(empty);	//消耗一个空闲缓冲区
            P(mutex);	//给缓冲区上锁
            放入一个产品;
            V(mutex);	//给缓冲区解锁
            V(full);	//释放一个产品
        }
    }
    
    //消费者
    consumer(){
        while(1){
            P(full);	//消耗一个产品
            P(mutex);	//给缓冲区上锁
            取走一个产品;
            V(mutex);	//给缓冲区解锁
            V(empty);	//释放一个空闲缓冲区
            使用产品;
        }
    }
    ```

  - 如果交换相邻的P操作，会导致两个进程发生死锁，所以**实现互斥操作的P操作一定要在实现同步的P操作之后**。

  - 交换相邻的V操作不会导致错误。

#### 2.4.8、==多生产者、多消费者问题==

- **问题描述**
  ![image-20241012130148080](C:\Users\di\Desktop\新建文件夹\image-20241012130148080.png)

- **问题分析**：
  - 盘子作为临界资源，需要被互斥访问，设互斥信号量**plate = 1**。
  - 爸爸放了苹果之后，女儿才能拿走苹果，设同步信号量**apple = 0**，有同步关系（父亲(v(apple))-->(p(apple))女儿）。
  - 妈妈放了橘子之后，儿子才能拿走橘子，设同步信号量**orange = 0**，有同步关系（母亲(v(orange))-->(p(orange))儿子）。
  - 儿子或女儿拿走水果之后，留下一个空盘，爸爸或妈妈才能放入水果，设同步信号量**emptyPlate = 1**，有同步关系（女儿or儿子(v(emptyPlat))-->(p(emptyPlat)父亲or母亲)。
    ![屏幕截图 2024-10-12 131214](C:\Users\di\Desktop\新建文件夹\屏幕截图 2024-10-12 131214.png)

- 功能实现

  - ```c
    //互斥信号量
    plate = 1;
    //同步信号量
    apple = 0;
    orange = 0;
    emptyPlate = 1;
    
    //father进程
    father(){
        while(1){
            P(emptyPlate);	//获取一个空盘
            p(plate);		//给盘子上锁
            放入苹果;
            v(Plate);		//给盘子解锁
            V(apple);		//释放苹果资源
        }
    }
    
    //mother进程
    mother(){
        while(1){
            P(emptyPlatr);	//获取一个空盘
            P(plate);		//给盘子上锁
            放入橘子;		
            V(plate);		//给盘子解锁
            V(orange);		//释放橘子资源
        }
    }
    
    //儿子进程
    son(){
        while(1){
            P(apple);	//获取苹果资源
            p(plate);	//给盘子上锁
           	拿走苹果;	
            v(plate);	//给盘子解锁
            v(emptyPlate);	//释放一个空盘资源
        }
    }
    
    //daughter进程
    daughter(){
        while(1){
            p(orange);	//获取橘子资源
            p(plate);	//给盘子上锁
            拿走橘子;
            v(plate);	//给盘子解锁
            v(emptyPlate);	//释放一个空盘资源
        }
    }
    ```

    

#### 2.4.9、==吸烟者问题==

- **问题描述**

  - ![image-20241013123305465](C:\Users\di\Desktop\新建文件夹\image-20241013123305465.png)

- **问题分析**

  - 供应者放入组合1（纸和胶水）后第一个吸烟者才能拿走，设定同步信号量**offer1 = 0**。

  - 供应者放入组合2（烟草和胶水）后第二个吸烟者才能拿走，设定同步信号量**offer2 = 0**。

  - 供应者放入组合3（纸和烟草）后第三个吸烟者才能拿走，设定同步信号量**offer3= 0**。

  - 只有当吸烟者吸完烟后供应者才能放入材料，设定同步信号量**isFinish = 1**。

  - 供应者轮流为吸烟者提供材料，设定计数变量**i = 0**。

    ![image-20241013124138561](C:\Users\di\Desktop\新建文件夹\image-20241013124138561.png)

- 问题实现：
  ![image-20241013124216203](C:\Users\di\Desktop\新建文件夹\image-20241013124216203.png)



#### 2.4.10、==**读者写者问题**==

- **问题描述**
  ![image-20241013143852821](C:\Users\di\Desktop\新建文件夹\image-20241013143852821.png)

- **问题分析**
  ![image-20241013143943224](C:\Users\di\Desktop\新建文件夹\image-20241013143943224.png)

- 问题实现
  - 互斥关系的实现：
    - 设置一个计数器变量count = 0;
    - 每个读进程要读文件时，判断count是否为0（判读是否有读进程给文件上锁）
    - 如果count为0，给文件上锁，令count++。表示当前文件已经有读文件在用了。如果count不为0，就不上锁，count++。
    - 读进程读完文件后令count--，如果此时count == 0，说明此时没有读进程在读文件，那么就给共享文件解锁。
    - 由于访问count操作和上锁解锁操作不是一体的，容易造成死锁，所以要把count和给共享资源上锁这两个操作也要上一把锁。
  - 读进程优先的实现
    - 在普通情况下，读进程远比写进程多，由于读进程读文件使不用上锁，这就导致会有源源不断地读进程一直运行，写进程进入饥饿状态。所以要保证写进程申请共享资源时，不会被其他读进程**插队**。
  - ![image-20241013150643543](C:\Users\di\Desktop\新建文件夹\image-20241013150643543.png)

#### 2.4.11、==哲学家进餐问题==

- **问题描述**
  ![image-20241014153613844](C:\Users\di\Desktop\新建文件夹\image-20241014153613844.png)

- **问题分析**

  ![image-20241014153656635](C:\Users\di\Desktop\新建文件夹\image-20241014153656635.png)

- **解决方案**

  - **方案一**：对哲学家进程施加一些限制，比如最多只允许四个哲学家同时进餐，这样可以保证至少有一个哲学家可以拿到左右两个筷子。

  - **方案二**：要求奇数号哲学家先拿左边的筷子，然后再拿右边的筷子，而偶数号哲学家刚好相反。这样可以让两个相邻哲学家竞争同一个筷子，没拿到的筷子直接阻塞。

  - **方案三：**哲学家拿起筷子这件事必须互斥的执行

    ![image-20241014154556968](C:\Users\di\Desktop\新建文件夹\image-20241014154556968.png)



#### 2.4.12、==管程==

- **为什么要引入管程？**

  - 信号量机制存在着编写程序困难、易出错的问题，操作不当易引发死锁。
  - Brinch Hansen首次在程序设计语言Pascal中引入了**管程**成分--一种高级同步机制，让程序员不再关注复杂的PV操作，让写代码更加轻松。

- **管程的定义和基本特征**

  - 管程是一种特殊的软件模块，类似于java中的**类**，由一下部分组成：
    - 局部于管程的**共享数据结构说明**，类似于类中的私有成员变量。
    - 对该数据结构进程操作的**一组过程**，类似于类中的方法。
    - 对局部管程的共享数据设置初始值的语句，类似于类中的构造方法。
    - 管程有一个名字，类似于类名。
  - **管程的基本特征**
    - 局部于管程的数据只能被局部于管程的过程所访问。
    - 一个进程只有通过调用管程内的过程才能进入管程访问共享数据。
    - **每次仅允许一个进程在管程内执行某个内部过程**。

- **管程思想解决生产者消费者问题**

  

![image-20241014182932749](C:\Users\di\Desktop\新建文件夹\image-20241014182932749.png)



### 2.5、死锁

#### 2.5.1、==死锁的概念==

> 在并发环境下，各进程因竞争资源而造成的一种**互相等待对方手里的资源，导致各进程都阻塞，都无法向前推进**的现象，就是死锁。

- **死锁、饥饿、死循环的区别**
  ![image-20241015123846295](C:\Users\di\Desktop\新建文件夹\image-20241015123846295.png)

- **死锁产生的条件** 

  ![image-20241015124457376](C:\Users\di\Desktop\新建文件夹\image-20241015124457376.png)

- **死锁的处理策略**

  ![image-20241015130928151](C:\Users\di\Desktop\新建文件夹\image-20241015130928151.png)

#### 2.5.2、==预防死锁==

- **破坏互斥条件**

  ![image-20241015131419773](C:\Users\di\Desktop\新建文件夹\image-20241015131419773.png)

- **破坏不剥夺条件**

  ![image-20241015131738287](C:\Users\di\Desktop\新建文件夹\image-20241015131738287.png)

- **破坏请求和保持条件**
  ![image-20241015132128971](C:\Users\di\Desktop\新建文件夹\image-20241015132128971.png)

- **破坏循环等待条件**

  ![image-20241015132645375](C:\Users\di\Desktop\新建文件夹\image-20241015132645375.png)



#### 2.5.3、==避免死锁==

- **安全序列、不安全状态、死锁的联系**
  ![image-20241016152532455](C:\Users\di\Desktop\新建文件夹\image-20241016152532455.png)

- **银行家算法**

  - **介绍**
    ![image-20241016163033723](C:\Users\di\Desktop\新建文件夹\image-20241016163033723.png)

  - **核心思想**

    ![image-20241016163056304](C:\Users\di\Desktop\新建文件夹\image-20241016163056304.png)

  - **如何实现**
    ![image-20241016164234133](C:\Users\di\Desktop\新建文件夹\image-20241016164234133.png)



#### 2.5.4、==死锁的检测和解除==

- **死锁的检测**
  - **检测死锁的思想**![image-20241016165517116](C:\Users\di\Desktop\新建文件夹\image-20241016165517116.png)
  - **检测死锁的算法**
    ![image-20241016165832736](C:\Users\di\Desktop\新建文件夹\image-20241016165832736.png)

- **死锁的解除**
  - **死锁解除的三种算法**
    ![image-20241016170300575](C:\Users\di\Desktop\新建文件夹\image-20241016170300575.png)
